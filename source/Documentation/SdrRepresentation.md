#  Working with SDRs

## Introduction: 
Neural network is a focal element in the area of machine learning. Inspired from the biological neurons that are present in the human brain, an artificial neural network is designed which mimics human brain’s behavior, helping computer programs to identify patterns and answers to these related issues. It would be able to perform actions like the human brain and has the capability of learning things. These neural networks work on the principle of learning input/output operations. In our project, SDR representation has been implemented in a variety of ways, including SDR as indices and bitmaps. Furthermore, we developed methods for comparing two SDRs by using intersection, union, and overlap. In addition, we have added a new representation of Spatial pooler learning as a "Column/Overlap" ratio, which is a another representation as  heatmap.

The inputs that we are using are scalar values and images. We specifed how these inputs are converted to SDR. Furthermore, this procedure of SDR representations involves the use of Encoders, Spatial Pooler (SP) and Temporal Memory (TM). Encoders are the basic components used in this network, which takes human justifiable information as input data i.e. (image, scalar value) and changes it to machine readable format, binary array with n size. SP uses these encoded binary arrays from encoders as an input for generation of SDRs.

TM is used to learn the sequence of these generated SDR’s which are given as an input from Spatial Pooler (SP).


#### What is an SDR:
According to recent research in neuroscience, our brain uses SDRs to process information. SDRs are the binary representation of data which is approximatly 2% of bits which are active. In SDRs, each bit has a meaning i.e. the active bits in the same places of two different vectors make them semantically similar. By comparing SDRs of different samples, the similarity between them can be estimated. For storing the SDRs, a list of indices of active bits are kept which saves a lot of space.



#### Functions dealing with SDRs:
SDRs are generated by passing an input to the encoder. Input can be anything like a number, time/date or an image. The type of encoder for each input is different. For example if our input is date and time we have to use DateTime Encoder and if our input is a number we use scaler encoder to encode it and represent it in form of SDRs. 
It is sometimes important to visualise the SDRs in different forms and make comparsions between them for a better understnding of the learning process. We are going to show you how to output SDRs as: 

  - Indices
  - Bitmaps
  - Heatmaps

Other than the representations, we will show you comparisons of different inputs by using overlap and instersection functions to see how different sdrs are similar or distinct semantically.

The functions which are used for the SDR representation are listed: 

- `NeoCortexApi.Helpers.StringifyVector`
- `NeoCortexUtils.DrawBitmap()`
- `DrawHeatmaps`


## How to output SDR as Indices:

SDR's are in the form of 0's & 1's, we have to look up for 1's everytime in an SDR array. So for simplification we just find the index number where SDR is 1.
SDR as Indices is the returning of the index number where SDRs bits are 1 of a binary array. 
If you like to visualise SDRs as indices, you can do it by using this function `NeoCortexApi.Helpers.StringifyVector` to get indices of the active (1) bits from the binary array. This function receives the encoded SDR and returns the index numbers of the SDR array where it is active.

The following is a code snippet for the functions mentioned above:

```csharp 
Debug.WriteLine(NeoCortexApi.Helpers.StringifyVector(ArrayUtils.IndexWhere(result, k => k == 1)));
``` 

The output of the preceding function is shown below:
```csharp 
SDR As Indices = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 
``` 

See more in [ScalarEncoderTestOverBitmap.cs](../UnitTestsProject/SdrRepresentation/ScalarEncoderTestOverBitmap.cs)

<!--- Code URL for the SDR Indices:

https://github.com/UniversityOfAppliedSciencesFrankfurt/se-cloud-2020-2021/blob/39475d910dd1bdbedc5e83be8bc72eefdd1259c7/MyProject/ML5.8SDRsRepresentations/OutputSDRs/Program.cs#L62
-->

## How to output SDR as bitmap: 

#### What is a Bitmap:
Bitmap is a type of file format which is used to store images. A bitmap is a spatially mapped array of bits i.e. a map of bits. For the purpose of representing SDRs as bitmaps, we first feed the output of encoders as inputs to the SP. #### Heatmap Function:

#### Bitmap Function:
You can visualise Bitmaps using the function `NeoCortexUtils.DrawBitmap()`. We will show you simply how it works. In the first step, you need to convert a one dimensional binary array into two-dimensional binary array using predefined function `ArrayUtils.Make2DArray`  as it is required for the conversion into bitmpas. Bitmaps are then generated from the 2D Array with or without a Transpose function `ArrayUtils.Transpose()`. Transpose function is used just to set the orientation. You can skip this part if you like. 

The following is a code snippet for the functions mentioned above:

```csharp 
int[,] twoDimenArray1 = ArrayUtils.Make2DArray<int>(Array, (int)Math.Sqrt(Array.Length), (int)Math.Sqrt(Array.Length));
int[,] twoDimenArray = ArrayUtils.Make2DArray<int>(activeArray, colDims[0], colDims[1]);
twoDimenArray = ArrayUtils.Transpose(twoDimenArray);
NeoCortexUtils.DrawBitmap(twoDimArray1, 1024, 1024, $"{outFolder}\\Overlap_{sdrs.Count}.png", Color.PaleGreen, Color.Red, text: $"Overlap.png");
``` 

Now we would like to explain what is going on here. The `Array` of first argument is a one dimensional binary array, the second argument `(int)Math.Sqrt(Array.Length)` outputs the value of rows and the third argument `(int)Math.Sqrt(Array.Length)` gives the column values. In order to set the orientation of the bitmap image, we additionally use `ArrayUtils.Transpose()` function. The `twoDimArray` is passed to the `NeoCortexUtils.DrawBitmap` function for the representation of SDR as a bitmap image. 

`twoDimArray1` is the SDR representation in binary form which is to be plotted. `1024 , 1024` shows the size of the final bitmap image. You can adjust it based on your requirements. `$"{outFolder}\\Overlap_{sdrs.Count}.png"` shows the path where output image is going to  be saved. `Color.PaleGreen, Color.Red` here you can set the colors of the On and Off bits. In my case, PaleGreen is for Off bits and Red is for On bits. `text: $"Overlap.png"` is it the text which is going to be visible on the top left of the image.  



The following images are the output of the function `NeoCortexUtils.DrawBitmap()` in the code snippets shown above:
|`Numbers`|`1`|`2`|`3`|`4`|`5`|
|--|--|--|--|--|--|
|Results|![][img1]|![][img2]|![][img3]|![][img4]|![][img5]|

[img1]: https://user-images.githubusercontent.com/59200478/113517493-ba1e1280-9599-11eb-8dfd-2e11e0ffe729.png
[img2]: https://user-images.githubusercontent.com/59200478/113517510-d5891d80-9599-11eb-8976-be6d4d8c805b.png
[img3]: https://user-images.githubusercontent.com/59200478/113517513-dc179500-9599-11eb-8baf-ee34092cbd16.png
[img4]: https://user-images.githubusercontent.com/59200478/113517520-e3d73980-9599-11eb-956d-c299a5b452f6.png
[img5]: https://user-images.githubusercontent.com/59200478/113517529-efc2fb80-9599-11eb-9eb7-90bbc97d42d5.png

See more in [ScalarEncoderTestOverBitmap.cs](../UnitTestsProject/SdrRepresentation/ScalarEncoderTestOverBitmap.cs)
<!----URL of SDR code as bitmap:

https://github.com/UniversityOfAppliedSciencesFrankfurt/se-cloud-2020-2021/blob/39475d910dd1bdbedc5e83be8bc72eefdd1259c7/MyProject/ML5.8SDRsRepresentations/OutputSDRs/Program.cs#L109
-->
## How to output SDR as Heatmap:

#### What is a Heatmap:
Sometimes is useful to see the activation of all cells. Some of them might be very active but still didn't reach the activation threshold. In such cases, the heatmap (URL) can be used. Heatmap is a graphical representation of data which uses a color coding system for representing different activation thresholds.

#### Heatmap Function:
If you are looking to create a heatmap of an SDR learning. you can use `DrawHeatmaps` function but with some minor changes in the arguments. A heatmap representation of SDRs will depict the active columns and categorize them in different colors based on their usage during learning. How we are using the `DrawHeatmaps` function for this purpose you can see the arguments we have used to generate heatmaps down below. A code snippet is shown for the creation of heatmaps: 

```csharp
 public static void DrawHeatmaps(List<double[,]> twoDimArrays, String filePath,
            int bmpWidth = 1024,
            int bmpHeight = 1024,
            decimal redStart = 200, decimal yellowMiddle = 127, decimal greenStart = 20)
```

Now here `decimal redStart = 200, decimal yellowMiddle = 127, decimal greenStart = 20` you can set the activation threshold of any cell with its color. In my case, red color is for the  cell which are activated more than  or equal to 200 times. Yellow color is for  the cells which are activated more than or equal to 127 times. And  green cells are those  who are activated for 20 time or more.  


For the representation of SDRs as heatmaps, we took the following images which are the SDRs generated by encoders:

|`SDR of number 1`|`SDR of number 3`|
|--|--|
|![][img6]|![][img7]|

[img6]: https://user-images.githubusercontent.com/53593496/125611277-aa10ec71-3da0-4e01-adec-97c781d10b27.png
[img7]: https://user-images.githubusercontent.com/53593496/125611309-f18f840e-c026-41ae-96c7-7800be676379.png


The function `NeoCortexUtils.DrawBitmap()` outputs the SDR as a heatmap. 

```csharp
NeoCortexUtils.DrawHeatmaps(overlapArrays, $"{outputImage}_overlap.png", 1024, 1024, red, red, green);
```

Following heatmaps are generated during the SDR Learning of number_1.jpeg and number_3.jpeg:

|`Heatmap of number 1`|`Heatmap of number 3`|
|--|--|
|![][img8]|![][img9]|

[img8]: https://user-images.githubusercontent.com/53593496/125611540-b50a57c6-1baf-4dd6-8d62-3ee4e04e3149.png
[img9]: https://user-images.githubusercontent.com/53593496/125611637-b011eb15-8d94-4f95-9061-148f3f93967f.png

See more in [SpatialPoolerColumnActivityTest.cs](../UnitTestsProject/SdrRepresentation/SpatialPoolerColumnActivityTest.cs)
<!---
URL of code of SDR as bitmap:

https://github.com/UniversityOfAppliedSciencesFrankfurt/se-cloud-2020-2021/blob/39475d910dd1bdbedc5e83be8bc72eefdd1259c7/MyProject/ML5.8SDRsRepresentations/OutputSDRs/SpatiaPoolerSimilarityOnHeatMap.cs#L188

-->
### Description of the steps followed in the project:

- In the first step, we take our inputs, such as a number or an image, and pass them through an encoder. We used date time, category, and scalar encoders for numerical values, and binarizer for image inputs. As the encoder output, we get a binary array (for example, 101010001).

- In the second step, the binary array is fed into SP in order for it to learn the SDRs of the input array.

- In the third step, we implement the functions that will allow us to represent the SDRs as bitmaps and heatmaps.

- Furthermore, for SDR analysis, we compare them using the following functions:

    **Get Array** \
    **Union** \
    **Overlap** \
    **Intersection** 

- Methods for analyzing columns and overlapping between multiple SDRs are also introduced, which analyzes columns and overlapping between two SDRs and generates an excel chart of all traces using the following functions:

    **Trace Active Columns** \
    **Trace Column Overlap**
  
 

## Functions used for the analysis of SDRs: 


### Get Array:

 This function takes SDR as indices `activeCols` as input and returns a binary array. The function we have defined is `GetIntArray()`. It take two inputs one is `activeCols` and `numOfCols`
 
 ```csharp
    GetIntArray(int[] activeCols, int numOfCols)
 ```
 
 
### Why we need it ?

When using procedures like Union, Overlap, and Intersection between two SDR, we often have to work with Active arrays rather than Active columns. Active array is a binary array representation of SDR in which the 1s bits are widely distributed, whereas active columns is an array containing the information of active column indicators. We must transform them using above function into active arrays in order to witness their Union, Overlap, and Intersection.


The output of the preceding function is shown below:
e.g 

```csharp
ActiveColumn:
214, 219, 534, 537, 549, 1628, 1641, 1753, 1766, 1822, 1823, 1825, 1830, 1833, 1881, 1889, 1893, 1897, 1940, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1954, 1955, 1956, 1959, 1960, 1961, 1962, 1963, 1966, 2007, 2009, 2010, 2011, 2012, 2013, 2016, 2019, 2021, 2022, 2023, 2024, 2025, 2026, 2071, 2072, 2073, 2080, 2085, 2086, 2088, 2134, 2136, 2138, 2139, 2143, 2144, 2145, 2151, 2153, 2201, 2211, 2266, 2267, 2272, 2328, 2339, 2340, 2341, 2344, 3485, 3608, 3622, 3931, 


Active array: 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 
```

URL of our class "SdrRepresentation" containing the GetIntArray Function:

https://github.com/UniversityOfAppliedSciencesFrankfurt/se-cloud-2020-2021/blob/9d24a1f16aa4b0b70f013efab71aa9440c7afe1e/MyProject/ML5.8SDRsRepresentations/OutputSDRs/SdrRepresentation.cs#L81

### Union Function: 

It will display the total number of "1's" in each column between two SDR images. A snippet of function is provided below. It takes two input binary arrays `arr1` and `arr2`. The resulting array will be used in conjunction with the overlapping array to create intersection:

 ```csharp
    UnionArraFun(int[] arr1, int[] arr2)
 ```

### Why we need it ?

In order to plot the intersection bitmap, the intersection function requires two input arrays. The outcome of the above function is one of the input arrays for that. You can also use it as a function to calculate the total number of active cells across numerous SDRs and plot the resulting bitmap images.


e.g This image is showing union between two SDRs:


<img src="https://user-images.githubusercontent.com/53593496/125617639-9959f6fe-370e-415a-9b2f-af236724cec9.png" width="500" height="500">

URL of our class "SdrRepresenation" in which you can find Union Function :

https://github.com/UniversityOfAppliedSciencesFrankfurt/se-cloud-2020-2021/blob/9d24a1f16aa4b0b70f013efab71aa9440c7afe1e/MyProject/ML5.8SDRsRepresentations/OutputSDRs/SdrRepresentation.cs#L53



### Overlap function: 
Overlap generates a binary array containing the common numbers of "1's" that occur in the same position for two SDRs. It takes two input binary arrays `arr1` and `arr2`. The result of this is also used further to create intersection between the SDRs:

```csharp  
           OverlapArraFun(int[] arr1, int[] arr2)
```

### Why we need it ?

It's required to filter the cells that are shared by two SDR arrays. The intersection function will be used to plot the common cells between two comparing SDRs, and in our case, the result of that has been be used in the intersection function. We find this function beneficial when all you need are common cells between two SDRs, which can be used to calculate the percentage of the common cell, our you can show are ratio of Common Cells/Total Cells and then be plotted to show where they belong.

e.g. This image is showing the output of overlap function between two SDRs:

<img src="https://user-images.githubusercontent.com/53593496/125617384-d5d93746-98b9-4f2d-9f96-7d9173458972.png" width="500" height="500">

URL of our class "SdrRepresenation" where you can find Overlap Function :

https://github.com/UniversityOfAppliedSciencesFrankfurt/se-cloud-2020-2021/blob/9d24a1f16aa4b0b70f013efab71aa9440c7afe1e/MyProject/ML5.8SDRsRepresentations/OutputSDRs/SdrRepresentation.cs#L26



### Intersection function: 

This function `DrawIntersections()` is used to create the intersection columns in red and the remaining columns of the two SDRs in gray by taking an Overlap array and a Union array as input. We have modified the code of draw bitmap to achieve this method, the function is showning below:

```csharp
      
      DrawIntersections(int[,] twoDimArray,int[,] twoDimArray2, int scale, String filePath, Color inactiveCellColor, Color activeCellColor, string text = null)
   
```

### Why we need it ?

Intersection bitmaps are really important function which can show you the overlap and union of comparing SDRs in a singal image. the resulting image will differentiate between them using different colors. we have created this function by modifiying the code of `DrawHeatmaps`. It is a method that we have introduced in this project to aid in the analysis of SDRs in a more meaningful way by utilizing the Intersection image. 


e.g. the image shows intersection between two SDRs

<img src="https://user-images.githubusercontent.com/53593496/125617803-ca5eec07-6772-4bff-a9c8-c6d1dad2a796.png" width="500" height="500">

URL of our class "SdrRepresenation" in which you can see Intersection Function :

https://github.com/UniversityOfAppliedSciencesFrankfurt/se-cloud-2020-2021/blob/9d24a1f16aa4b0b70f013efab71aa9440c7afe1e/MyProject/ML5.8SDRsRepresentations/OutputSDRs/SdrRepresentation.cs#L259


### Trace Active Columns:

For tracing the active coloumns of the SDR you need to extract the indicies of the active cell and store them in an array which is called Activearray. Function is provided below. During execution, the aim for creating this function is to display the active columns of each SDR generated during Spatial Pooler learning in the output window using `Helpers.StringifyVector()`:

```csharp
 
          TraceActiveColumns(int cycle, string trainingImage, int[] activeCols)               
       
```
### Why we need it ?

It is the simplest form of function that we have created which is helping in tracing the active columns of all the SDR created during SDR learning. For this function which we are using `Helpers.StringifyVector()` which will return the indexes of the bits that are set to 1's as a result


e.g:
```csharp
 
InputArray: 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

ActiveColumn:
214, 219, 534, 537, 549, 1628, 1641, 1753, 1766, 1822, 1823, 1825, 1830, 1833, 1881, 1889, 1893, 1897, 1940, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1954, 1955, 1956, 1959, 1960, 1961, 1962, 1963, 1966, 2007, 2009, 2010, 2011, 2012, 2013, 2016, 2019, 2021, 2022, 2023, 2024, 2025, 2026, 2071, 2072, 2073, 2080, 2085, 2086, 2088, 2134, 2136, 2138, 2139, 2143, 2144, 2145, 2151, 2153, 2201, 2211, 2266, 2267, 2272, 2328, 2339, 2340, 2341, 2344, 3485, 3608, 3622, 3931, 

```


URL of our class "SdrRepresenation" in which you can see "TraceActiveColumns" Function :

https://github.com/UniversityOfAppliedSciencesFrankfurt/se-cloud-2020-2021/blob/9d24a1f16aa4b0b70f013efab71aa9440c7afe1e/MyProject/ML5.8SDRsRepresentations/OutputSDRs/SdrRepresentation.cs#L118

### Trace Columns Overlap:

This function will represent the radios for Column/overlaps. We defined the "TraceColumnsOverlap()" method, which prints the SDR of an input image in the format "Column / Overlap." After the SP SDR learning process is completed, each column is printed along with the number of overlaps that column has. The Function is pasted below:

```csharp
            TraceColumnsAndCells(List<double[,]> overlapArrays, StreamWriter swActCol1)      
       
```

### Why we need it ?

Our professor suggests another approach to portray SDR as a "Column / Overlap" ratio. which used the TraceColumnsAndCells() function to build this SDR representation. We prepared an excel sheet using the trial version of Excel. We may further drive numerous excel charts employing excel charts.

e.g:
|`Output in Excel`|`Graph between Column (X Axis)  and Overlap (Y Axis)`|
|--|--|
|![][img13]|![][img14]|

[img13]: https://user-images.githubusercontent.com/74202550/121780870-916e5680-cba2-11eb-81a5-0776fb94ff93.PNG
[img14]: https://user-images.githubusercontent.com/74202550/121780884-a77c1700-cba2-11eb-902f-b994f5041372.PNG

URL of our class "SdrRepresenation" in which you can find TraceColumnsOverlap Function :

https://github.com/UniversityOfAppliedSciencesFrankfurt/se-cloud-2020-2021/blob/9d24a1f16aa4b0b70f013efab71aa9440c7afe1e/MyProject/ML5.8SDRsRepresentations/OutputSDRs/SdrRepresentation.cs#L144

## Guide to implement SDR representation samples: 

We'll walk you through some of the examples we've used to teach SDR functions and their outputs in this guide. To begin your experiment, consider what you'll need. You'll need an input, which can be a scalar value or an image. And those inputs must be converted into binary arrays, that is what we are going to do first.
In the very first step, we would take an input and give it to an encoder for getting its binary array. Once we get the binary array, we can represent them in different ways.

We have taken the below shown images as inputs:
|`Binary Array image_1.png`|`Binary Array Image_3.png`|
|--|--|
|![][img3]|![][img4]|

[img3]: https://user-images.githubusercontent.com/53593496/125618365-10693de3-3c02-49b7-9e62-a51c3ac7f3bd.png
[img4]: https://user-images.githubusercontent.com/53593496/125618599-2a1be5c7-adbb-40ad-8882-2d51a149c858.png

Input `image_1.jepg` is then passed to an encoder, which will give us the below-mentioned result as a binary array:
```csharp
ResultArray:
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
```

We now have successfully generated binary arrays. and we can proceed towards their representation in the coming steps.

A binary array differs from an SDR in that it has active cells that are not sparsely scattered. You can plot a binary array to examine this difference, and you'll observe that active cells appear adjacent to each other. the first this you need for SDR representation is achived till here which is binary array of the input. 


Binary array of the input images are: 
|`Binary array of image_1.png`|`Binary array of Image_3.png`|
|--|--|
|![][img15]|![][img6]|

[img15]: https://user-images.githubusercontent.com/74202550/126381438-cea282f8-b1a0-4820-a3db-85f0c45d0de9.png
[img6]: https://user-images.githubusercontent.com/53593496/125618851-1db737e9-b88f-4ca9-96e5-776046d9f308.png

It can be useful to see the activation of all cells on occasion. Even though some of them are extremely active, they have not yet reached the activation threshold. The heatmap (URL) can be utilized in these situations. durring SDR learning there is a process of activating cells untill the who cycle of SDR learning is completed in Spatial Pooler. In order to analyise which cells were used during learning  we can see it using heatmap. it is also a ploted  using the same function are `DrawHeatmaps` with some  additional parameters. In 2nd step you will pass the binary array to SDR `sp.compute()` as an input vector and it is will start the Spatial Pooler learning process. the final result you will get after this is the SDR of the input and also the heatmap of SDR learning.

Let's use the heatmap function `DrawHeatmaps` to see how SDRs learning will look.
Following heatmap is generated during the SDR Learning of Image_1.jpeg and Image_3.jpeg:

|`Heatmap of image_1.png`|`Heatmap of Image_3.png`|
|--|--|
|![][img7]|![][img8]|

[img7]: https://user-images.githubusercontent.com/53593496/125619093-f127b501-168c-461b-9344-a6731b77d8ea.png
[img8]: https://user-images.githubusercontent.com/53593496/125619272-4bcbf3d9-ed7b-4007-a1f1-9da58a139751.png


For further observation, In the third step let's compare the SDRs by taking their overlap, Union and intersection and analysing their outputs. Now, here's something that we've added to the project. This results in the intersection of two SDRs. in order to find the point where two SDRs intersect. It's critical that you create the union and overlap arrays first, as they'll be used as inputs to the intersection method. You will not get the correct result if you do not utilize overlap and union before producing intersection.

`GetArray()` function will convert the activeCols into a binary array which can further be used to create the union, overlap and intersection between the SDRs of image_1.jpeg and image_3.jpeg

```csharp
Image_1 Binary array: 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 


Image_3 Binary array: 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
```

|`Intersection`|`Overlap`|`Union`|
|--|--|--|
|![][img8]|![][img9]|![][img10]|

[img8]: https://user-images.githubusercontent.com/53593496/125619412-0f5c3a13-ca8b-4686-843a-828c708180a9.png
[img9]: https://user-images.githubusercontent.com/53593496/125619466-ff0a1c61-c421-47ca-87f9-375bfd2af65f.png
[img10]: https://user-images.githubusercontent.com/53593496/125619575-41e9d849-ae65-44f5-853d-213d60bd635e.png

 lastly by "TraceColumnsOverlap()" function you can also represent SDR in excel format. It is another way you can represent SDR. The ratio `Column/Overlap`shows the cell column and the overlap which it will have during SDR learning. One useful information you can get form this ratio is which no of cells are used frequently during SDR learning. further you can plot them using excel tables 
SDR representation of the inputs in `Column/Overlap` format:

|`Output in Excel`|`Graph between Column (X Axis)  and Overlap (Y Axis)`|
|--|--|
|![][img11]|![][img12]|

[img11]: https://user-images.githubusercontent.com/74202550/121780870-916e5680-cba2-11eb-81a5-0776fb94ff93.PNG
[img12]: https://user-images.githubusercontent.com/74202550/121780884-a77c1700-cba2-11eb-902f-b994f5041372.PNG

